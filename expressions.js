// parseInt(typeof (123 + 'test'), 29)
//     `1. Конкатениреум 123 + 'test', в выражении сложение и строка, значит соединяем как строку.`
// parseInt(typeof ('123test'), 29)
//     `2. Применяем оператор typeof к '123test'. Получаем тип 'string'.`
// parseInt('string', 29);
//     `3. В 29 системе счиления s - последний символ, t - нет - выдаст ошибку и выведет 28 (s = 28)`;
// 28;
//
// Number([] + null / 25)
//     `1.Так как операция деления имеет выше приоритет чем сложения, первым делом выполняем ее.
//     Null преобразовываем в число, так как при делении все преобразовывается в число`;
// Number([] + 0);
//     `2. Операция сложения обьекта с числом. Выполняется ToPrimitive(hint number), а затем toNumber. Получаем '' -> 0;`
// Number(0 + 0) -> 0
//
// {} + '25'
//     `1. Сложение со строкой вызывает метод обекта toPrimitive(hint String) -> toString() -> ''`;
// '' + '25' = '25'
//
// parseInt(('' + Boolean(('abc' / 4).toString()[0]))[3], 15);
// `1. Первой операцией будет деление с преобразованием 'abc' в число. Получим NaN.`
// parseInt(('' + Boolean((NaN).toString()[0]))[3], 15);
// `2. NaN с toString вернут строку 'NaN', а [0] ее первый символ 'N'`
// parseInt(('' + Boolean('N'))[3], 15);
// `3. Boolean('N') - преобразование непустой строки вернет true`;
// parseInt(('' + true)[3], 15);
// `4. Конкатанация пустой строки с true вернет нам строку 'true',  4й символ будет 'e'`;
// parseInt('e', 15);
// `5. Так как 'e' в 15 системе счисления 14, получим 14`;
// parseInt('e', 15); -> 14;
//
// Number('\r\n 123.5') * '4'
//     `1. Обрезание пробельных символов и преобразование в число Number('\r\n 123.5') вернет нам 123.5`;
// 123.5 * '4';
// `2. При умножении строковая '4' преобразуется в 4`
// 123.5 * 4 = 494
//
// !('false' || 'undefined') + 1
//     `1. 'false' || 'undefined' вернет 'false' (Boolean('false') -> true), первое истинное значение.`
// !('false') + 1
//     `2. Boolean('false') -> true -> !true -> false`;
// false + 1
//     `3. false -> Number(false) -> 0`;
// 0 + 1 = 1;
//
// '25' > 24 > '26' > '        -1     '
//     `1. Пооперационно первым выполнится сравнение '25' > 24 -> 25 преобразуется в число и получим true`;
// true > '26' > '        -1     '
//     `2. Сравниваем true > '26' -> 1 > 26 -> false`;
// false > '        -1     '
//     `2. Сравниваем false  > '        -1     ' -> 0 > -1 -> true`;
// true
//
// ({ valueOf () { return 5 } }) == ([1, 2, 3][2] + +'2')
//     `1. { valueOf () { return 5 } } при == вернет toPrimitive(hint Number) -> 5`;
// 5 == ([1, 2, 3][2] + +'2')
//     `2. ([1, 2, 3][2] + +'2') -> 3й элемент массива + Number('2')`;
// 5 == (3 + 2);
// `3. При сравнении отпределит, что типы одинаковае и применит 5 === 5, где определит что это число и сравнит значения.`;
// 5 == 5 = true
//
// typeof void function () { return 7 } ();
// `1. void вернет undefined, а typeof undefined = 'undefined';
//
// Object.is(1 / 0 / Infinity, (1, 'test', true, NaN))
// `1. 1 / 0 -> Infinity`;
// Object.is(Infinity / Infinity, (1, 'test', true, NaN))
// `2. Infinity / Infinity -> преобразование к числу -> NaN`;
// Object.is(NaN, (1, 'test', true, NaN));
// `3. (1, 'test', true, NaN) -> получаем последний элемент -> NaN`;
// Object.is(NaN, NaN);
// `4. Сравнение конструкцией Object.is в отличое от других сравнений возвращает true при сравнении NaN значений`;